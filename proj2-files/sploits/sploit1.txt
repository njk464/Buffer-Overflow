We exploited target 1's stack/buffer overflow vulnerability to open a shell prompt as root, despite the fact that target1 was run in user mode. We accomplished this by first noticing that the target program allocated a buffer space of 60 with which to transfer our argument into, and the target program did not perform any sort of checking to ensure that we had, in fact, sent only up to 60 bytes worth of data, nor did the target program ensure that only up to 60 bytes worth of data would be copied into the target program's buffer. The program could easily have been patched had strncopy() been used with the proper buffer size specified, rather than strcopy(), which only looks for the null character to know when to terminate copying and does no length checking.

Our exploit code involves assigning args[1] -- the argument being passed to the target program -- strings of byte codes that, when executed, cause a root shell to begin running. We follow these bytecodes up with bytecodes of empty value in order to fill up the buffer, such that 
(bytecodes for shell) + (meaningless bytecodes) = 60, which is the size of the buffer that the target program allocated. We then overflow the buffer with "xaa/xff/xff/xbf", which overwrites the return address that the target program originally intended to use, with the address 0xbfffffaa, which is the address that our shell code starts out. The program then uses our address, which causes our code to run and a root shell to open.
