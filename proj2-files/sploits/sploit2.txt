The basic premise on this(#2) buffer overflow attack is the same as the basic premise for the buffer overflow attack that we used in sploit1. However, our target2 program did introduce length checking in an effort to prevent any buffer overflow attacks, and while the program's efforts did make our attack slightly more complicated, it certainly did not prevent us from successfully exploiting a buffer overflow vulnerability to execute a root shell. The big flaw within target2 is the terminating logic used in the for-loop located in nstrcopy(). This for-loop used a variable int i, starting at 0 and continuing while i <= (checked_size). The problem with this logic is that the program continues through the loop for i = checked_size, which means that, rather than the programmer's presumed intention of only iterating checked_size times, the for-loop actually goes through checked_size + 1 iterations. This subtle programming error enabled us to pass a string argument of exactly 80 bytes, with + 1 NULL byte to terminate the string, which caused the NULL byte to be written past the allocated buffer. Target2 checked our 80 byte argument, then began copying the 80 bytes of our argument (which contained the shell bytecode, pointer address to point at our shell bytecode, and meaningless bytes for padding) into the allocated buffer, and then writing the NULL byte just past the allocated buffer. Circumstances have it that this single NULL byte was written into a return address saved on the stack, and because the stack grows toward lower memory addresses, overwriting the return address with the NULL byte causes the return address to point back into the buffer. We constructed a pointer address that pointed at the beginning of our shell bytecode presently in the buffer, and, after some calculations, we were able to indirectly place this pointer into the memory address that the program's overwritten return pointer now pointed to. This means that, when the program tried to return, it would "return" to a memory address in the buffer, and this memory address then pointed towards the start of our shell bytecode (still in the buffer.) The program would then execute our malicious code and open a root shell for us.
