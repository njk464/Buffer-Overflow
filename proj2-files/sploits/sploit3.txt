In target3.c, there is a local "widget_t" buffer of size "MAX_WIDGETS". Each "widget_t" is 56 bytes, and "MAX_WIDGETS" is defined as the number 50, so the total number of bytes allocated for the local buffer is 2800. Target3.c does attempt to do some length checking at line 21: if(count < MAX_WIDGETS). This line checks if the signed int "count" is less than 50, if count is not less than 50, then the program does not perform a memcpy() -- this was intended to prevent buffer overflow which would result if we tried to read (50+) * (56) >= 2800 bytes. However, target3.c makes the mistake of creating "count" as a signed int, rather than an unsigned int. This allows us to pass a very large negative number into target3.c, in our case: -1764004375, which passes the if statement at line 21 and, when multiplied by the size of widget_t, gives us the int 2808. Target3.c would then try to copy 2808 bytes of our attack buffer into target3's local buffer, which would overflow the local buffer, and overwrite the return address with our address that points back at the beginning of the shell code that is now stored in the local buffer. 

We found the "magic number" -1764004375 by creating a quick script that multiplies each possible negative number by 56, and outputs anything in the realm of 2808 (and there were a few more negative ints that we could have used instead to achieve the same result.) This is the essence of our buffer overflow exploit -- multiplication overflow. 

Target3 could have prevented this vulnerability by declaring "count" as an unsigned int, so that the intention behind "if(count < MAX_WIDGET)" would not have been undermined by our passing of a negative int. Alternatively, Target3 could have changed "if(count < MAX_WIDGET)" to 
"if( (count*sizeof(widget_t)) < (MAX_WIDGETS * sizeof(widget_t)))", as this would have handled the case of multiplication overflow and prevented the copying of x >= 2800 bytes.  
